<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Blogs on Collin&#39;s Blog</title>
    <link>https://clsss.github.io/blog/blogs/</link>
    <description>Recent content in Blogs on Collin&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zn-Hans</language>
    <lastBuildDate>Sun, 23 Dec 2018 20:24:11 +0800</lastBuildDate>
    
	<atom:link href="https://clsss.github.io/blog/blogs/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Nuxt.js</title>
      <link>https://clsss.github.io/blog/blogs/2018-12/nuxt/</link>
      <pubDate>Sun, 23 Dec 2018 20:24:11 +0800</pubDate>
      
      <guid>https://clsss.github.io/blog/blogs/2018-12/nuxt/</guid>
      <description>一. Nuxt.js 介绍 vue + vuex + vue-router + SSR + vue-meta 官网 Nuxt.js 是一个基于 Vue.js 的通用应用框架。 通过对客户端/服务端基础架构的抽象组织，Nuxt.js 主要关注的是应用的 UI 渲染。 我们的目标是创建一个灵活的应用框架，你可以基于它初始化新项目的基础结构代码，或者在已有 Node.js 项目中使用 Nuxt.js。 特性 基于 Vue.js 自动代码分层 服务端渲染 强大的路由功能，支持异步数据 静态文件服务 ES6/ES7 语法支持 打包和压缩 JS 和 CSS HTML 头部标签管理 本地开发支持热加载 集成 ESLint 支持各种</description>
    </item>
    
    <item>
      <title>Redis</title>
      <link>https://clsss.github.io/blog/blogs/2018-6/redis/</link>
      <pubDate>Sun, 23 Dec 2018 20:24:11 +0800</pubDate>
      
      <guid>https://clsss.github.io/blog/blogs/2018-6/redis/</guid>
      <description>一. Redis 介绍 Redis 是一个开源的使用 ANSI C 语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value 数据库，并提供多种语言的 API。从 2010 年 3 月 15 日起，Redis 的开发工作由 VMware 主持。从 2013 年 5 月开始，Redis 的开发由 Pivotal 赞助。 快速读写 性能： 测试完成了 50 个并发执行 100000 个请求。 设置和获取的值是一个 256 字节字符串。 Linux box 是运行 Linux 2.6,这是 X3320 Xeon 2.5 ghz。 文本执行使用 loopback 接口(127.0.0.1)。 结果:读的速度是 110000</description>
    </item>
    
    <item>
      <title>移动端_Web如何调起App</title>
      <link>https://clsss.github.io/blog/blogs/2017-9/m_communicate_app/</link>
      <pubDate>Tue, 25 Sep 2018 23:12:11 +0800</pubDate>
      
      <guid>https://clsss.github.io/blog/blogs/2017-9/m_communicate_app/</guid>
      <description>一. 判断机型（Ios/Android） /* * 设备检测 * @return {{isIos:Function, isAndroid:Function}} */ export function getBrowserVersion() { const ua = navigator.userAgent || navigator.vendor || window.opera const uaInfo = { ios: /\(i[^;]+;( U;)? CPU.+Mac OS X/i.test(ua), android: /Android/i.test(ua) || /Linux/i.test(ua) } return { isIos() { return uaInfo.ios }, isAndroid() { return uaInfo.android } } } 二. 分类套路 1. Android 安卓有 2 种常用方式： a.自定义 Scheme b.Chrome Intent 自定义 Scheme scheme 协议在 app 注册之后，与前端进行统一约定，通过 H5 页面访问某个具体的协议地址，即可打开对应的 app 客户端页面。 1. 通过a标签打开，点击标签是启动 &amp;lt;a href=&amp;quot;m://app.com?openid=1</description>
    </item>
    
    <item>
      <title>RESTful</title>
      <link>https://clsss.github.io/blog/blogs/2018-10/restful/</link>
      <pubDate>Sat, 25 Aug 2018 23:12:11 +0800</pubDate>
      
      <guid>https://clsss.github.io/blog/blogs/2018-10/restful/</guid>
      <description>RESTful API 这里我就直接把阮一峰老师的文章 copy 过来了。 引用：阮一峰 RESTful API 最佳实践 RESTful 是什么？ RESTful 是目前最流行的 API 设计规范，用于 Web 数据接口的设计。 它的大原则容易把握，但是细节不容易做对。本文总结 RESTful 的设计细节，介绍如何设计出易于理解和使用的 API。 RESTful 的核心思想就是，客户端发出的数据操作指令都是&amp;rdquo;动词 + 宾语&amp;rdquo;的结构。比如，GET /articles 这个命令，GET 是动词，/articles 是宾语。 一、URL 设计 1.1</description>
    </item>
    
    <item>
      <title>jsonp跨域原理</title>
      <link>https://clsss.github.io/blog/blogs/2018-8/cross_domain/</link>
      <pubDate>Sat, 25 Aug 2018 23:12:11 +0800</pubDate>
      
      <guid>https://clsss.github.io/blog/blogs/2018-8/cross_domain/</guid>
      <description>一. 跨域: 浏览器对于 javascript 的同源策略的限制,例如 a.cn 下面的 js 不能调用 b.cn 中的 js,对象或数据(因为 a.cn 和 b.cn 是不同域),所以跨域就出现了 同源策略: 请求的 url 地址,必须与浏览器上的 url 地址处于同域上,也就是域名,端口,协议相同. 比如:我在本地上的域名是 study.cn,请求另外一个域名一段数据 JSONP 的优点是：它不像 XMLHttpRequest 对象实现的 Ajax 请求那样受到同源策略的限制；它的兼容性更好，在更加古老的浏览器中都可以运行，不需要 XMLHttpRequest 或 ActiveX 的支</description>
    </item>
    
    <item>
      <title>编程思想-函数式编程</title>
      <link>https://clsss.github.io/blog/blogs/2018-7/programming_ideas/</link>
      <pubDate>Sun, 15 Jul 2018 20:42:11 +0800</pubDate>
      
      <guid>https://clsss.github.io/blog/blogs/2018-7/programming_ideas/</guid>
      <description>编程的思想 函数式编程,所属于声明式编程 面向对象编程(OOP)通过封装变化使得代码更易理解。 函数式编程(FP)通过最小化变化使得代码更易理解。 &amp;ndash; Michacel Feathers（Twitter） 设计原则： 可扩展性&amp;ndash;添加新功能是否需要修改以前的代码？ 易模块化&amp;ndash;修改了一个模块，另一个模块是否会受到影响？ 可重用性&amp;ndash;是否有很多重复的代码？ 可测性&amp;ndash;给函数添加单元测试是否让你难</description>
    </item>
    
    <item>
      <title>mongoDB环境搭建，服务器端</title>
      <link>https://clsss.github.io/blog/blogs/2018-6/mongodb/</link>
      <pubDate>Wed, 20 Jun 2018 20:24:11 +0800</pubDate>
      
      <guid>https://clsss.github.io/blog/blogs/2018-6/mongodb/</guid>
      <description>一. MongoDB 介绍 MongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。 MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。 优点： 高可扩展性 分布式存储 低成本 结构灵活 二. 使用 mongoDB 1. 安装 安装方式 # 执行后会返回安装后的路径 which mongod 2. 启动方式： 安装注意事项 需要 db 存储和日志存储文件夹 添加服务，配置环境变量，启动 mongod 方式 1： 打开 cmd 输入 services.msc 查</description>
    </item>
    
    <item>
      <title>docker探索</title>
      <link>https://clsss.github.io/blog/blogs/2018-6/docker/</link>
      <pubDate>Sun, 10 Jun 2018 20:42:11 +0800</pubDate>
      
      <guid>https://clsss.github.io/blog/blogs/2018-6/docker/</guid>
      <description>docker 镜像（Image）+ 容器（Container）+ 仓库（Repository） 下载： linux： sudo wget -qO- http:get.docker.com | sh sudo usermod -aG docker xbf // 不用 sodu windows： 官网下载：https://docs.docker.com/engine/installation/ 命令行： #是否docker安装成功 $ docker run hello-world #查看docker信息 $ docker info $ docker -v #获取镜像（使用别人的镜像） $ docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签] #</description>
    </item>
    
    <item>
      <title>设计模式-设计模式（不常用）</title>
      <link>https://clsss.github.io/blog/blogs/2018-5/design/designmode3/</link>
      <pubDate>Mon, 07 May 2018 20:54:11 +0800</pubDate>
      
      <guid>https://clsss.github.io/blog/blogs/2018-5/design/designmode3/</guid>
      <description>设计模式-设计模式 这是一种模板 三大类型（23 种模式）： 创建型 工厂模式 单列模式 原型模式 组合型 适配器模式 修饰器模式 代理模式 外观模式 桥接模式 组合模式 享元模式 行为型 策略模式 模板方法模式 观察者模式（重） 迭代器模式（重） 职责连模式 命令模式 备忘录模式 状态模式（重） 访问者模式 中介则模式 解释器模式 1. 原型模式： 基于原有数据复制一份 bash var protptype = { getName: function () { return this.name }, say: function () { console.log(&#39;hello&#39;) } } Object.create(protptype) 桥接模式: 用于把抽象化与实现化解耦 二者独立变化 组</description>
    </item>
    
    <item>
      <title>设计模式-设计模式（常用）</title>
      <link>https://clsss.github.io/blog/blogs/2018-5/design/designmode2/</link>
      <pubDate>Mon, 07 May 2018 20:54:11 +0800</pubDate>
      
      <guid>https://clsss.github.io/blog/blogs/2018-5/design/designmode2/</guid>
      <description>设计模式-设计模式 这是一种模板 三大类型（23 种模式）： 创建型 工厂模式 单列模式 原型模式 组合型 适配器模式 修饰器模式 代理模式 外观模式 桥接模式 组合模式 享元模式 行为型 策略模式 模板方法模式 观察者模式（重） 迭代器模式（重） 职责连模式 命令模式 备忘录模式 状态模式（重） 访问者模式 中介则模式 解释器模式 1. 工厂模式： 将 new 操作单独封装 构造器的名字不能乱改=。= 例 1： 买东西，你传入钱，东西名 ==&amp;gt; 最后就返东西。至于中间的东西是哪里</description>
    </item>
    
    <item>
      <title>设计模式-设计原则</title>
      <link>https://clsss.github.io/blog/blogs/2018-5/design/designmode1/</link>
      <pubDate>Sat, 05 May 2018 20:54:11 +0800</pubDate>
      
      <guid>https://clsss.github.io/blog/blogs/2018-5/design/designmode1/</guid>
      <description>设计模式-设计原则（五大原则） 这是一种思想。 1. 单一职责原则（S） 就像.then().then()每个 then 只做一件事 2. 开发封闭原则（O） 新增代码，以前的代码不变 3. 李氏置换原则（L） 子类能覆盖父类 父类出现的地方，子类就能出现 4. 接口独立原则（I） 保持接口独立 5. 依赖导致原则（D） 面向接口编程，依赖于抽象而不依赖于具体 使用方只关注接口不关注具体实现 js 中更多的是关注（S, O）</description>
    </item>
    
    <item>
      <title>测试&amp;持续构建</title>
      <link>https://clsss.github.io/blog/blogs/2018-4/mocka/</link>
      <pubDate>Wed, 25 Apr 2018 20:54:11 +0800</pubDate>
      
      <guid>https://clsss.github.io/blog/blogs/2018-4/mocka/</guid>
      <description>测试&amp;amp;持续构建 一. api 测试 频繁地将代码集成到主干 每次集成都通过自动化的构建来验证 优点： 1. 尽早发现错误 防止分支大幅度偏离主干 工具 egg—— https://github.com/eggjs/egg 持续构建： https://travis-ci.org/eggjs/egg 文档： https://docs.travis-ci.com/ benchmark 性能测试 benchmark.js suite .add(&#39;parseInt()&#39;, () =&amp;gt; { num1(&#39;123465&#39;); }) .add(&#39;Number&#39;, () =&amp;gt; { num2(&#39;123456&#39;); }) .on(&#39;cycle&#39;, event =&amp;gt; { console.log(String(event.target)); }) .on(&#39;complete&#39;, function() { console.log(&#39;Fastest is &#39; + this.filter(&#39;fastest&#39;).map(&#39;name&#39;)); }) .run({async: true}); 二. UI 测试 jest 三 爬虫 爬虫: 按照一定的需求自动抓取网络信息 反爬虫: user-agent，referer, 验证码 单位时间访问次数 关键信息用图片混淆 异步加载 使用：suppe</description>
    </item>
    
    <item>
      <title>Hugo 搭建博客</title>
      <link>https://clsss.github.io/blog/blogs/2017-10/hugo/</link>
      <pubDate>Wed, 25 Oct 2017 20:54:11 +0800</pubDate>
      
      <guid>https://clsss.github.io/blog/blogs/2017-10/hugo/</guid>
      <description>基于 Hogo 快速搭建静态网站 本来使用 Hexo, 也是极好的，素材也很多。但是文章一旦多了。慢速度又怎么让人心安，所以使用 Hugo 作一次尝试。一起来看看如何使用 hugo 搭建自己 blog. 附上中文网 安装 Hugo 工欲兴其事必先利器。 安装 Git 安装 Go 安装 Mercurial 安装 Hugo 具体步骤官网很详细 使用 Windows 的小伙伴就有点难受了。由于地址是国外的，所以没有翻墙的小伙伴，下载靠运气 请确保安装好后添加全局路径 在本地创建自己的站点 在你想创建站点的地方下执行 $ hugo new site [文件夹] # 进入</description>
    </item>
    
    <item>
      <title>webpack-css处理</title>
      <link>https://clsss.github.io/blog/blogs/2018-4/webpack/css/</link>
      <pubDate>Wed, 25 Oct 2017 20:54:11 +0800</pubDate>
      
      <guid>https://clsss.github.io/blog/blogs/2018-4/webpack/css/</guid>
      <description>css 处理 webpack 是如何引入 css？ style-loader（2. 创建 link 标签） a. style-loader b. style-loader/url（file-loader） c. style-loader/useable（ user()，unuser() ） options:{ insertInto: &#39;#app&#39;， // 插入到app节点 singleton: true, // 是否重用 transform: &#39;./css.transform.js&#39; // 可以做样式的修改 } css-loader（1.import css） option:{ minimize: true, // 压缩css modules: true // 开启css模块化开发 } css modules &amp;gt; 配置 less/sass rules: [ { test: /\.less$/, use:ExtractTextWebpackPlugin.extract([ {},</description>
    </item>
    
    <item>
      <title>webpack-prerenderer</title>
      <link>https://clsss.github.io/blog/blogs/2018-4/webpack/webpack-prerendererpuppeteer%E7%89%88/</link>
      <pubDate>Wed, 25 Oct 2017 20:54:11 +0800</pubDate>
      
      <guid>https://clsss.github.io/blog/blogs/2018-4/webpack/webpack-prerendererpuppeteer%E7%89%88/</guid>
      <description>预渲染 1.run build生成打包html和资源上传cdn 2.利用生成的html 启动本地服务 3.使用puppeteer爬去启动的服务页面的html 4.生成预渲染后的html 命令行： &amp;quot;build-pre&amp;quot;: &amp;quot;npm run clean &amp;amp;&amp;amp; node build/build.js --pre --e&amp;quot;, // --pre为Boolean，设置了则启动预渲染模式 build.js ``` console.log(chalk.magentaBright(&amp;rsquo; Build Complete.And coding in ./dist \n &amp;lsquo;)) // 预渲染 const prerenderPromise = await prerender() if (isPre &amp;amp;&amp;amp; prerenderPromise) { prerenderPromise .then(() =&amp;gt; { spinner.stop() console.log(chalk.cyan(&amp;rsquo; Prerender complete.\n&amp;rsquo;)) }) .catch((e) =&amp;gt; { console.log(chalk.red(Prerender failed with errors.\n${e})) process.exit(1) }) } 2. prerender.js /* * config/index.js文件中配置了assetsPubli</description>
    </item>
    
    <item>
      <title>webpack-ssr</title>
      <link>https://clsss.github.io/blog/blogs/2018-4/webpack/webpack-ssr/</link>
      <pubDate>Wed, 25 Oct 2017 20:54:11 +0800</pubDate>
      
      <guid>https://clsss.github.io/blog/blogs/2018-4/webpack/webpack-ssr/</guid>
      <description>webpack-ssr webpack.server.conf.js 不用关心测试环境还是正式环境 只需要再服务端能跑起来，不需要压缩等.. /* * @Author: _collin【collinssem@126.com】 * @Date: 2018-04-28 09:26:38 * @Last Modified by: _collin * @Last Modified time: 2018-04-28 09:47:53 * 服务端渲染配置文件 */ const path = require(&#39;path&#39;) const ExtractPlugin = require(&#39;extract-text-webpack-plugin&#39;) const webpack = require(&#39;webpack&#39;) const merge = require(&#39;webpack-merge&#39;) const baseConf = require(&#39;./webpack.base.conf&#39;) // const VueServerPlugin = require(&#39;vue-server-renderer/server-plugin&#39;) let config const isDev = process.env.NODE_ENV === &#39;development&#39; const plugins = [ new ExtractPlugin(&#39;styles.[Hash:8].css&#39;), new webpack.DefinePlugin({ &#39;process.env.NODE_ENV&#39;: JSON.stringify(process.env.NODE_ENV || &#39;development&#39;), &#39;process.env.VUE_ENV&#39;: &#39;&amp;quot;server&amp;quot;&#39; }) ] if (isDev) { // 这个插件，让我们服务端打包后无.js文件而是.json文件 // 这个包会帮我们做很多事情 plugins.push(new VueServerPlugin()) } config = merge(baseConf, { target: &#39;node&#39;, // nod</description>
    </item>
    
    <item>
      <title>webpack4升级</title>
      <link>https://clsss.github.io/blog/blogs/2018-4/webpack/webpack4%E5%8D%87%E7%BA%A7/</link>
      <pubDate>Wed, 25 Oct 2017 20:54:11 +0800</pubDate>
      
      <guid>https://clsss.github.io/blog/blogs/2018-4/webpack/webpack4%E5%8D%87%E7%BA%A7/</guid>
      <description>webpack4升级 webpack升级（4.6版） 一、dev-server 本地运行一个静态服务 1. 添加了mode，直接区分development和production 2. 插件的替换： a. webpack.DefinePlugin（不用了，已经有mode了） b. webpack.CommonsChunkPlugin 被替代成: optimization配置中配置splitChunks(指定vendor在这个配置里)和runtimeChunk c. UglifyJsPlugin --&amp;gt; optimizat</description>
    </item>
    
    <item>
      <title>前端构建分享（入门篇）</title>
      <link>https://clsss.github.io/blog/blogs/2018-4/webpack/vue-cli/</link>
      <pubDate>Wed, 25 Oct 2017 20:54:11 +0800</pubDate>
      
      <guid>https://clsss.github.io/blog/blogs/2018-4/webpack/vue-cli/</guid>
      <description>vue-cli 前提 node.js, vue-cli 全局安装脚手架 npm install -g -vue-cli 你需要了解npm/yarn的相关知识，还有淘宝镜像cnpm（主要是用在资源被墙） 尤其是： cnpm install node-sass sass-loader -D 新建一个vue 项目流程： vue init webpack &amp;lt;项目名称&amp;gt; cd .. npm install npm run dev 注意：要使用npm包管理器就必须安装node（原因：包含关系 ———— nodejs中含有npm，安装好nodejs后，你打开cmd输入npm -v会发现npm的版本号，说明npm已经安装好） node.js是</description>
    </item>
    
    <item>
      <title>移动端_性能优化</title>
      <link>https://clsss.github.io/blog/blogs/2017-9/m_performance/</link>
      <pubDate>Mon, 25 Sep 2017 23:12:11 +0800</pubDate>
      
      <guid>https://clsss.github.io/blog/blogs/2017-9/m_performance/</guid>
      <description>scroll 实际上，Safari 真的用了原生控件来实现，对于有-webkit-overflow-scrolling 的网页，会创建一个 UIScrollView，提供子 layer 给渲染模块使用 IOS（safari）： -webkit-overflow-scrolling: touch; // 弹簧效果 安卓： overflow:auto; // winphone8 和 android4+ bug： 当你给一个元素设置过 position:absolute;或者 position:relative;后再增加-webkit-overflow-scrolling: touch</description>
    </item>
    
    <item>
      <title>移动端_机型判断</title>
      <link>https://clsss.github.io/blog/blogs/2017-9/m_useragent/</link>
      <pubDate>Mon, 25 Sep 2017 23:12:11 +0800</pubDate>
      
      <guid>https://clsss.github.io/blog/blogs/2017-9/m_useragent/</guid>
      <description>判断机型（Ios/Android） function getBrowserVersion() { var ua = navigator.userAgent || navigator.vendor || window.opera; var uaInfo = { ios: !!ua.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/i), android: ua.match(/Android/i) || ua.match(/Linux/i) }; var browserVersion = { isIos: function () { return uaInfo.ios; }, isAndroid: function () { return uaInfo.android; } }; return browserVersion; } 相应的机型发送相应的请求 if (openId) { if (browserVersion.isIos()) { window.webkit.messageHandlers.jumpToVerify.postMessage(&#39;verifyProspr&#39;); } else if (browserVersion.isAndroid()) { android.jumpPage(-9); } } else { goDownload(); } 相应的机型跳转相应的链接 if (browserVersion.isIos()) { location.href = &#39;http://app.appsflyer.com/id873518909?pid=web&amp;amp;c=index&#39;; } else if (browserVersion.isAndroid()) { location.href = &#39;http://app.appsflyer.com/com.luxy?pid=web&amp;amp;c=index&#39;; } 通知客户端修改右上角 feedback 图标 if (browserVersion.isIos()) { window.webkit.messageHandlers.JSMessage_shouldShowFeedbackButton.postMessage(); } else if (browserVersion.isAndroid()) { android.forceShowFeedbackOnTitleBar(); } 包括电脑跳转链接 $(&#39;.btn&#39;).click(function(){ var ua = navigator.userAgent.toLowerCase(); var userAgent = navigator.userAgent var t = Date.now(); var info = window.location.search.substr(1); var info2 = window.location.search.substr(1); if (/ipad|iphone|mac/i.test(ua)){ if (userAgent.indexOf(&amp;quot;Safari&amp;quot;) &amp;gt; -1) { window.location = &amp;quot;OMGmart://&amp;quot; + info; setTimeout(&amp;quot;window.location.href = &#39; &#39;,3000); } else { alert</description>
    </item>
    
    <item>
      <title>移动端_禁止竖屏</title>
      <link>https://clsss.github.io/blog/blogs/2017-9/m_no_portrait/</link>
      <pubDate>Mon, 25 Sep 2017 23:12:11 +0800</pubDate>
      
      <guid>https://clsss.github.io/blog/blogs/2017-9/m_no_portrait/</guid>
      <description>禁止竖屏 (function rotate(){ var orientation=window.orientation; //当屏幕方向改变时 if(orientation==90||orientation==-90){ document.body.style.display=&#39;none&#39;; alert(&amp;quot;请使用竖屏访问！&amp;quot;); } window.onorientationchange=function(){ document.body.style.display=&amp;quot;block&amp;quot;; rotate(); }; })() 禁止选择 &amp;lt;style type=&amp;quot;text/css&amp;quot;&amp;gt; .user_select_none { -webkit-tap-highlight-color: rgba(0, 0, 0, 0.5); -webkit-touch-callout: none; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; } &amp;lt;/style&amp;gt;</description>
    </item>
    
    <item>
      <title>移动端——响应式布局</title>
      <link>https://clsss.github.io/blog/blogs/2017-9/m_adapter/</link>
      <pubDate>Mon, 25 Sep 2017 23:12:11 +0800</pubDate>
      
      <guid>https://clsss.github.io/blog/blogs/2017-9/m_adapter/</guid>
      <description>一、rem/em 单位 rem ( font size of root element) 相对长度单位。相对于根元素(即 html 元素)font-size 计算值的倍数 栗子： &amp;lt;style&amp;gt; html{ font-size: 12px; } p { font-size: 2rem; } &amp;lt;/style&amp;gt; &amp;lt;body&amp;gt; &amp;lt;p&amp;gt;我是html定义的12px的2倍，字体大小为24px&amp;lt;/p&amp;gt; &amp;lt;/body&amp;gt; # 如上如果我们设定html的字体大小为12px，有一段文字设置了font-size：2rem # 那么意思就是这段文字的font-siez是根元素的2倍，则12*2 = 24px; # 当然一般情</description>
    </item>
    
    <item>
      <title>第三方登录——微信登录</title>
      <link>https://clsss.github.io/blog/blogs/2017-8/wx/</link>
      <pubDate>Fri, 25 Aug 2017 23:12:11 +0800</pubDate>
      
      <guid>https://clsss.github.io/blog/blogs/2017-8/wx/</guid>
      <description>微信登录 微信官方文档 一、引入微信 SDK，前端引入引入如下 JS 文件（支持 https）【微信提供】 http://res.wx.qq.com/connect/zh_CN/htmledition/js/wxLogin.js 二、生成二维码(signIn.vue) html: &amp;lt;div id=&amp;quot;login-wx&amp;quot;&amp;gt;&amp;lt;/div&amp;gt; js: 生成二维码 需要 new WxLogin({}) 实例 appid：微信 AppID redirect_uri：扫码后重定向地址 href：控制二维码样式 # encodeURIComponent会把 http:// 编码成 http%3A%2F%2F 而 encodeURI却不会 # 这里是使用node生成一段微信二维码样式 // eslint-disable-next-line const WX_CODE_STYLE = &#39;data:text/css;base64,&#39; + &#39;LmltcG93ZXJCb3ggLnFyY29kZSB7d2lkdGg6IDIwMHB4O30NCi5pbXBvd&#39; + &#39;2VyQm94IC50aXRsZSB7ZGlzcGxheTogbm9uZTt9DQoua&#39; + &#39;W1wb3dlckJveCAuaW5mbyB7d2lkdGg6IDIwMHB4O30NCi5zdGF0dXNfaW&#39; + &#39;NvbiB7ZGlzcGxheTpub25lfQ0KLmltcG93ZXJCb3ggLnN0YXR1cyB7dGV4dC1hbGlnbjogY2VudGVyO30=&#39; const WX_APPID =</description>
    </item>
    
    <item>
      <title>HTTP超文本传输协议</title>
      <link>https://clsss.github.io/blog/blogs/2017-7/http/</link>
      <pubDate>Tue, 25 Jul 2017 23:12:11 +0800</pubDate>
      
      <guid>https://clsss.github.io/blog/blogs/2017-7/http/</guid>
      <description>HTTP超文本传输协议 1.定义： 超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。 所有的 WWW 文件都必须遵守这个标准。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。 HTTP 是一个客户端和服务器端请求和应答的标准（TCP） HTTP 协议（HyperText Transfer Protocol，超文本传输协议）是用于从 WWW 服务器传输超文本到本地浏览器的传输协议。它可以使浏览器更加</description>
    </item>
    
    <item>
      <title>v-distpicker城市插件</title>
      <link>https://clsss.github.io/blog/blogs/2017-6/v-distpicker/</link>
      <pubDate>Sun, 25 Jun 2017 23:12:11 +0800</pubDate>
      
      <guid>https://clsss.github.io/blog/blogs/2017-6/v-distpicker/</guid>
      <description>v-distpicker城市插件 官网 安装 npm install v-distpicker --save 或者 yarn add v-distpicker --save 使用方式 import VDistpicker from &#39;v-distpicker&#39; Vue.component(&#39;v-distpicker&#39;, VDistpicker) 千万注意: :province=&amp;lsquo;==province==&amp;rsquo;,中绑定的省, 不能通过@province=&amp;ldquo;==selectProvince==&amp;ldquo;方法直接修改(市和区同理). 用于显示与用于绑定的值是2个不同的值 Demo 方式1：无默认选中的城市 &amp;lt;!-- html --&amp;gt; &amp;lt;v-distpicker @province=&amp;quot;selectProvince&amp;quot; @city=&amp;quot;selectCity&amp;quot; @area=&amp;quot;selectArea&amp;quot;&amp;gt;&amp;lt;/v-distpicker&amp;gt; &amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;{{ select }}&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt; &amp;lt;!-- js --&amp;gt; export default { components: { VDistpicker }, data()</description>
    </item>
    
    <item>
      <title>前端模块化</title>
      <link>https://clsss.github.io/blog/blogs/2017-6/module/</link>
      <pubDate>Sun, 25 Jun 2017 23:12:11 +0800</pubDate>
      
      <guid>https://clsss.github.io/blog/blogs/2017-6/module/</guid>
      <description>一.为什么前端需要模块化 随着前端的不断发展，前端已经不仅仅是一个简单依据需求完成网页开发的过程，如何提高网页开发效率，提高代码复用率，降低块与块之间的耦合性是我们需要思考的问题，而前端的组件化、模块化正是解决这样的问题。 二.模块化与组件化 1. 什么是前端模块化 模块化侧重的功能的封装，主要是针对Javascript代码，隔离、组织复制的javascript代码，将它封装成一个个具有特定功能的的模块 模块可</description>
    </item>
    
    <item>
      <title>pm2</title>
      <link>https://clsss.github.io/blog/blogs/2017-5/pm2/</link>
      <pubDate>Thu, 25 May 2017 22:13:01 +0800</pubDate>
      
      <guid>https://clsss.github.io/blog/blogs/2017-5/pm2/</guid>
      <description>pm2 是什么？ pm2 是一个带有负载均衡功能的 Node 应用的进程管理器.当然也支持性能监控，进程守护，负载均衡等功能。当你要把你的独立代码利用到全部的服务器上的所有 CPU，并保证进程永远都活着，0 秒的重载， PM2 是完美的。它非常适合 IaaS 结构，但不要把它用于 PaaS 方案（随后将开发 Paas 的解决方案）. 官网：http://pm2.keymetrics.io/docs/usage/quick-start/ 需要小心.ssh 和一些翻墙问题</description>
    </item>
    
    <item>
      <title>Gulp工具</title>
      <link>https://clsss.github.io/blog/blogs/2017-4/gulp/</link>
      <pubDate>Tue, 25 Apr 2017 20:54:11 +0800</pubDate>
      
      <guid>https://clsss.github.io/blog/blogs/2017-4/gulp/</guid>
      <description>Gulp 是什么？ Gulp 用自动化构建工具增强你的工作流程！ 1.易于使用: 通过代码优于配置的策略，Gulp 让简单的任务简单，复杂的任务可管理。 2.构建快速: 利用 Node.js 流的威力，你可以快速构建项目并减少频繁的 IO 操作。 3.插件高质: Gulp 严格的插件指南确保插件如你期望的那样简洁高质得工作。 4.易于学习: 通过最少的 API，掌握 Gulp 毫不费力，构建工作尽在掌握：如同一系列流管道。 中文文档地址. var gulp = require(&#39;gulp&#39;); var less = require(&#39;gulp-less&#39;); var browserSync = require(&#39;browser-sync&#39;).create(); // 静态服务器 var</description>
    </item>
    
  </channel>
</rss>
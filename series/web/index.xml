<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Web on Collin&#39;s Blog</title>
    <link>https://clsss.github.io/blog/series/web/</link>
    <description>Recent content in Web on Collin&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zn-Hans</language>
    <lastBuildDate>Tue, 25 Sep 2018 23:12:11 +0800</lastBuildDate>
    
	<atom:link href="https://clsss.github.io/blog/series/web/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>移动端_Web如何调起App</title>
      <link>https://clsss.github.io/blog/blogs/2017-9/m_communicate_app/</link>
      <pubDate>Tue, 25 Sep 2018 23:12:11 +0800</pubDate>
      
      <guid>https://clsss.github.io/blog/blogs/2017-9/m_communicate_app/</guid>
      <description>一. 判断机型（Ios/Android） /* * 设备检测 * @return {{isIos:Function, isAndroid:Function}} */ export function getBrowserVersion() { const ua = navigator.userAgent || navigator.vendor || window.opera const uaInfo = { ios: /\(i[^;]+;( U;)? CPU.+Mac OS X/i.test(ua), android: /Android/i.test(ua) || /Linux/i.test(ua) } return { isIos() { return uaInfo.ios }, isAndroid() { return uaInfo.android } } } 二. 分类套路 1. Android 安卓有 2 种常用方式： a.自定义 Scheme b.Chrome Intent 自定义 Scheme scheme 协议在 app 注册之后，与前端进行统一约定，通过 H5 页面访问某个具体的协议地址，即可打开对应的 app 客户端页面。 1. 通过a标签打开，点击标签是启动 &amp;lt;a href=&amp;quot;m://app.com?openid=1</description>
    </item>
    
    <item>
      <title>RESTful</title>
      <link>https://clsss.github.io/blog/blogs/2018-10/restful/</link>
      <pubDate>Sat, 25 Aug 2018 23:12:11 +0800</pubDate>
      
      <guid>https://clsss.github.io/blog/blogs/2018-10/restful/</guid>
      <description>RESTful API 这里我就直接把阮一峰老师的文章 copy 过来了。 引用：阮一峰 RESTful API 最佳实践 RESTful 是什么？ RESTful 是目前最流行的 API 设计规范，用于 Web 数据接口的设计。 它的大原则容易把握，但是细节不容易做对。本文总结 RESTful 的设计细节，介绍如何设计出易于理解和使用的 API。 RESTful 的核心思想就是，客户端发出的数据操作指令都是&amp;rdquo;动词 + 宾语&amp;rdquo;的结构。比如，GET /articles 这个命令，GET 是动词，/articles 是宾语。 一、URL 设计 1.1</description>
    </item>
    
    <item>
      <title>移动端_Web如何调起App</title>
      <link>https://clsss.github.io/blog/blogs/2018-8/cross_domain/</link>
      <pubDate>Sat, 25 Aug 2018 23:12:11 +0800</pubDate>
      
      <guid>https://clsss.github.io/blog/blogs/2018-8/cross_domain/</guid>
      <description>一. 跨域: 浏览器对于 javascript 的同源策略的限制,例如 a.cn 下面的 js 不能调用 b.cn 中的 js,对象或数据(因为 a.cn 和 b.cn 是不同域),所以跨域就出现了 同源策略: 请求的 url 地址,必须与浏览器上的 url 地址处于同域上,也就是域名,端口,协议相同. 比如:我在本地上的域名是 study.cn,请求另外一个域名一段数据 1.1 jsonp 例子 # page1： &amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt; var message = function(data) { alert(data[1].title); }; &amp;lt;/script&amp;gt; &amp;lt;script type=&amp;quot;text/javascript&amp;quot; src=&amp;quot;http://web.cn/js/message.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt; # message.js message([ {&amp;quot;id&amp;quot;:&amp;quot;1&amp;quot;, &amp;quot;title&amp;quot;:&amp;quot;aaa&amp;quot;}, {&amp;quot;id&amp;quot;:&amp;quot;2&amp;quot;, &amp;quot;title&amp;quot;:&amp;quot;bbb&amp;quot;}, ]);</description>
    </item>
    
    <item>
      <title>前端构建分享（入门篇）</title>
      <link>https://clsss.github.io/blog/blogs/2018-4/webpack/vue-cli/</link>
      <pubDate>Wed, 25 Oct 2017 20:54:11 +0800</pubDate>
      
      <guid>https://clsss.github.io/blog/blogs/2018-4/webpack/vue-cli/</guid>
      <description>vue-cli 前提 node.js, vue-cli 全局安装脚手架 npm install -g -vue-cli 你需要了解npm/yarn的相关知识，还有淘宝镜像cnpm（主要是用在资源被墙） 尤其是： cnpm install node-sass sass-loader -D 新建一个vue 项目流程： vue init webpack &amp;lt;项目名称&amp;gt; cd .. npm install npm run dev 注意：要使用npm包管理器就必须安装node（原因：包含关系 ———— nodejs中含有npm，安装好nodejs后，你打开cmd输入npm -v会发现npm的版本号，说明npm已经安装好） node.js是</description>
    </item>
    
    <item>
      <title>移动端_性能优化</title>
      <link>https://clsss.github.io/blog/blogs/2017-9/m_performance/</link>
      <pubDate>Mon, 25 Sep 2017 23:12:11 +0800</pubDate>
      
      <guid>https://clsss.github.io/blog/blogs/2017-9/m_performance/</guid>
      <description>scroll 实际上，Safari 真的用了原生控件来实现，对于有-webkit-overflow-scrolling 的网页，会创建一个 UIScrollView，提供子 layer 给渲染模块使用 IOS（safari）： -webkit-overflow-scrolling: touch; // 弹簧效果 安卓： overflow:auto; // winphone8 和 android4+ bug： 当你给一个元素设置过 position:absolute;或者 position:relative;后再增加-webkit-overflow-scrolling: touch</description>
    </item>
    
    <item>
      <title>移动端_机型判断</title>
      <link>https://clsss.github.io/blog/blogs/2017-9/m_useragent/</link>
      <pubDate>Mon, 25 Sep 2017 23:12:11 +0800</pubDate>
      
      <guid>https://clsss.github.io/blog/blogs/2017-9/m_useragent/</guid>
      <description>判断机型（Ios/Android） function getBrowserVersion() { var ua = navigator.userAgent || navigator.vendor || window.opera; var uaInfo = { ios: !!ua.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/i), android: ua.match(/Android/i) || ua.match(/Linux/i) }; var browserVersion = { isIos: function () { return uaInfo.ios; }, isAndroid: function () { return uaInfo.android; } }; return browserVersion; } 相应的机型发送相应的请求 if (openId) { if (browserVersion.isIos()) { window.webkit.messageHandlers.jumpToVerify.postMessage(&#39;verifyProspr&#39;); } else if (browserVersion.isAndroid()) { android.jumpPage(-9); } } else { goDownload(); } 相应的机型跳转相应的链接 if (browserVersion.isIos()) { location.href = &#39;http://app.appsflyer.com/id873518909?pid=web&amp;amp;c=index&#39;; } else if (browserVersion.isAndroid()) { location.href = &#39;http://app.appsflyer.com/com.luxy?pid=web&amp;amp;c=index&#39;; } 通知客户端修改右上角 feedback 图标 if (browserVersion.isIos()) { window.webkit.messageHandlers.JSMessage_shouldShowFeedbackButton.postMessage(); } else if (browserVersion.isAndroid()) { android.forceShowFeedbackOnTitleBar(); } 包括电脑跳转链接 $(&#39;.btn&#39;).click(function(){ var ua = navigator.userAgent.toLowerCase(); var userAgent = navigator.userAgent var t = Date.now(); var info = window.location.search.substr(1); var info2 = window.location.search.substr(1); if (/ipad|iphone|mac/i.test(ua)){ if (userAgent.indexOf(&amp;quot;Safari&amp;quot;) &amp;gt; -1) { window.location = &amp;quot;OMGmart://&amp;quot; + info; setTimeout(&amp;quot;window.location.href = &#39; &#39;,3000); } else { alert</description>
    </item>
    
    <item>
      <title>移动端_禁止竖屏</title>
      <link>https://clsss.github.io/blog/blogs/2017-9/m_no_portrait/</link>
      <pubDate>Mon, 25 Sep 2017 23:12:11 +0800</pubDate>
      
      <guid>https://clsss.github.io/blog/blogs/2017-9/m_no_portrait/</guid>
      <description>禁止竖屏 (function rotate(){ var orientation=window.orientation; //当屏幕方向改变时 if(orientation==90||orientation==-90){ document.body.style.display=&#39;none&#39;; alert(&amp;quot;请使用竖屏访问！&amp;quot;); } window.onorientationchange=function(){ document.body.style.display=&amp;quot;block&amp;quot;; rotate(); }; })() 禁止选择 &amp;lt;style type=&amp;quot;text/css&amp;quot;&amp;gt; .user_select_none { -webkit-tap-highlight-color: rgba(0, 0, 0, 0.5); -webkit-touch-callout: none; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; } &amp;lt;/style&amp;gt;</description>
    </item>
    
    <item>
      <title>第三方登录——微信登录</title>
      <link>https://clsss.github.io/blog/blogs/2017-8/wx/</link>
      <pubDate>Fri, 25 Aug 2017 23:12:11 +0800</pubDate>
      
      <guid>https://clsss.github.io/blog/blogs/2017-8/wx/</guid>
      <description>微信登录 微信官方文档 一、引入微信 SDK，前端引入引入如下 JS 文件（支持 https）【微信提供】 http://res.wx.qq.com/connect/zh_CN/htmledition/js/wxLogin.js 二、生成二维码(signIn.vue) html: &amp;lt;div id=&amp;quot;login-wx&amp;quot;&amp;gt;&amp;lt;/div&amp;gt; js: 生成二维码 需要 new WxLogin({}) 实例 appid：微信 AppID redirect_uri：扫码后重定向地址 href：控制二维码样式 # encodeURIComponent会把 http:// 编码成 http%3A%2F%2F 而 encodeURI却不会 # 这里是使用node生成一段微信二维码样式 // eslint-disable-next-line const WX_CODE_STYLE = &#39;data:text/css;base64,&#39; + &#39;LmltcG93ZXJCb3ggLnFyY29kZSB7d2lkdGg6IDIwMHB4O30NCi5pbXBvd&#39; + &#39;2VyQm94IC50aXRsZSB7ZGlzcGxheTogbm9uZTt9DQoua&#39; + &#39;W1wb3dlckJveCAuaW5mbyB7d2lkdGg6IDIwMHB4O30NCi5zdGF0dXNfaW&#39; + &#39;NvbiB7ZGlzcGxheTpub25lfQ0KLmltcG93ZXJCb3ggLnN0YXR1cyB7dGV4dC1hbGlnbjogY2VudGVyO30=&#39; const WX_APPID =</description>
    </item>
    
    <item>
      <title>HTTP超文本传输协议</title>
      <link>https://clsss.github.io/blog/blogs/2017-7/http/</link>
      <pubDate>Tue, 25 Jul 2017 23:12:11 +0800</pubDate>
      
      <guid>https://clsss.github.io/blog/blogs/2017-7/http/</guid>
      <description>HTTP超文本传输协议 1.定义： 超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。 所有的 WWW 文件都必须遵守这个标准。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。 HTTP 是一个客户端和服务器端请求和应答的标准（TCP） HTTP 协议（HyperText Transfer Protocol，超文本传输协议）是用于从 WWW 服务器传输超文本到本地浏览器的传输协议。它可以使浏览器更加</description>
    </item>
    
    <item>
      <title>前端模块化</title>
      <link>https://clsss.github.io/blog/blogs/2017-6/module/</link>
      <pubDate>Sun, 25 Jun 2017 23:12:11 +0800</pubDate>
      
      <guid>https://clsss.github.io/blog/blogs/2017-6/module/</guid>
      <description>一.为什么前端需要模块化 随着前端的不断发展，前端已经不仅仅是一个简单依据需求完成网页开发的过程，如何提高网页开发效率，提高代码复用率，降低块与块之间的耦合性是我们需要思考的问题，而前端的组件化、模块化正是解决这样的问题。 二.模块化与组件化 1. 什么是前端模块化 模块化侧重的功能的封装，主要是针对Javascript代码，隔离、组织复制的javascript代码，将它封装成一个个具有特定功能的的模块 模块可</description>
    </item>
    
    <item>
      <title>pm2</title>
      <link>https://clsss.github.io/blog/blogs/2017-5/pm2/</link>
      <pubDate>Thu, 25 May 2017 22:13:01 +0800</pubDate>
      
      <guid>https://clsss.github.io/blog/blogs/2017-5/pm2/</guid>
      <description>pm2 是什么？ pm2 是一个带有负载均衡功能的 Node 应用的进程管理器.当然也支持性能监控，进程守护，负载均衡等功能。当你要把你的独立代码利用到全部的服务器上的所有 CPU，并保证进程永远都活着，0 秒的重载， PM2 是完美的。它非常适合 IaaS 结构，但不要把它用于 PaaS 方案（随后将开发 Paas 的解决方案）. 官网：http://pm2.keymetrics.io/docs/usage/quick-start/ 需要小心.ssh 和一些翻墙问题</description>
    </item>
    
    <item>
      <title>Gulp工具</title>
      <link>https://clsss.github.io/blog/blogs/2017-4/gulp/</link>
      <pubDate>Tue, 25 Apr 2017 20:54:11 +0800</pubDate>
      
      <guid>https://clsss.github.io/blog/blogs/2017-4/gulp/</guid>
      <description>Gulp 是什么？ Gulp 用自动化构建工具增强你的工作流程！ 1.易于使用: 通过代码优于配置的策略，Gulp 让简单的任务简单，复杂的任务可管理。 2.构建快速: 利用 Node.js 流的威力，你可以快速构建项目并减少频繁的 IO 操作。 3.插件高质: Gulp 严格的插件指南确保插件如你期望的那样简洁高质得工作。 4.易于学习: 通过最少的 API，掌握 Gulp 毫不费力，构建工作尽在掌握：如同一系列流管道。 中文文档地址. var gulp = require(&#39;gulp&#39;); var less = require(&#39;gulp-less&#39;); var browserSync = require(&#39;browser-sync&#39;).create(); // 静态服务器 var</description>
    </item>
    
  </channel>
</rss>